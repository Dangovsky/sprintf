#include <string> 
#include <iostream> 
#include <stdarg.h>

using namespace std;

int My_snprintf(char *buffer, size_t count, const char *format, ...)
{
	//Write formatted data to a string.
	//Записывает форматированные данные в строку
	/*Параметры
	buffer
	Место хранения выходных данных.

	count
	Наибольшее число символов для хранения.

	format
	Строка управления форматом.

	(...) - способ передачи любого количества аргументов в с++
	Необязательные аргументы.
	*/

	// счетчики для циклов
	int i = 0, // для format
		j = 0, // для buffer
		k;	// для записи аргументов
	va_list argptr; // системный лист для доступа к аргументам на месте (...) в определении функции

	va_start(argptr, format); // инициализация листа

	// в с++ bool-ом может быть любое число. Если оно == 0, то это false иначе true
	while ((bool)(count - j) & (bool)(format[i])) // Цикл идет пока не выйдем за ограничение на количество записываемых символов, или не кончится строка формата
	{
		if (format[i] == '%') // если нашли начало специального символа
		{
			i++; // переходим на следующий элемент
			if (!((bool)(count - j) | (bool)(format[i]))) // если вышли за ограничения на количество записываемых символов, или кончилась строка формата, то выходим
				continue;

			switch (format[i]) // смотрим что лежит после '%'
			{
			case 's': // если там s, то нужно считать строку из переданных аргументов и записать ее
			{
				char* str = va_arg(argptr, char*); // считывание следующего аргумента и преобразование его в char* (строку)
				k = 0; // обнуляем счетчик
				while ((bool)(str[k]) & (bool)(count - j)) // цикл идет пока не кончится записываемая строка, или не выйдем на ограничение на количество записываемых символов
				{
					buffer[j] = str[k]; // пишем
					k++; j++; // увеличиваем счетчики
				}
				i++; // еще счетчик
				continue;
			}
			case 'd': // если там d, то нужно считать целое число и записать его
			{
				int d = va_arg(argptr, int); //читаем число
				char* str = _strdup(to_string(d).c_str()); //преобразуем его в char* (строку)
				// дальше все точно как в случае строки
				k = 0;
				while ((bool)(str[k]) & (bool)(count - j))
				{
					buffer[j] = str[k];
					k++; j++;
				}
				i++;
				continue;
			}
			case 'f':
			{
				// тут все аналогично случаю целого числа, но int заменено на float
				float f = va_arg(argptr, float);
				char* str = _strdup(to_string(f).c_str());
				k = 0;
				while ((bool)(str[k]) & (bool)(count - j))
				{
					buffer[j] = str[k];
					k++; j++;
				}
				i++;
				continue;
			}
			default: // если % оказалость просто %, а не спец символом то записываем его
			{
				buffer[j++] = '%';
				continue;
			}
			}
		}
		else // если не %, то просто записываем
		{
			buffer[j] = format[i];
		}
		i++; j++; // увеличиваем счетчики
	}

	va_end(argptr); // освобождаем лист аргументов
	return 0;
}

int main()
{
	char *str = new char[100]; // char* - местный аналог string. Можно обращаться как к массиву char (str[i]). Также можно обращаться *(str + i)	
	My_snprintf(str, 50, "this is string: %s, this is number: %d, this is %", "test_string", 54); // Функции передается: 1 - строка, в которую производится запись, 2 - наибольшее число символов для записи,
																									// 3 - строка со специальными символами типа %s, %d и %f, на место которых будут вписанны следующие переменные, 
																									// 4 - переменные, количество которых равно количеству специальных символов с соответствующими типами:
																									// %s - string / строка; %d - digit / целое число; %f - float / число с плавующей запятой
																									// У нас на место $s встанет test_string, на место %d - 54.
	// строка обрубается потому, что она длиннее, чем ограничие на максимально количество символов. И вся остальная строка будет заполнени мусором из оперативной памяти.
	cout << str;
	cin >> str;
	delete[] str;

}
